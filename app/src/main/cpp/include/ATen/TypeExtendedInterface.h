#pragma once
#include <ATen/Type.h>

namespace at {

struct CAFFE2_API TypeExtendedInterface : public Type {
  explicit TypeExtendedInterface(TensorTypeId type_id, bool is_variable, bool is_undefined)
      : Type(type_id, is_variable, is_undefined) {}
  virtual Tensor & _th_set_(Tensor & self, Storage source) const = 0;
  virtual Tensor & _th_set_(Tensor & self, Storage source, int64_t storage_offset, IntArrayRef size, IntArrayRef stride) const = 0;
  virtual Tensor & _th_set_(Tensor & self, const Tensor & source) const = 0;
  virtual Tensor & _th_set_(Tensor & self) const = 0;
  virtual Tensor & _th_fill_(Tensor & self, Scalar value) const = 0;
  virtual Tensor & _th_fill_(Tensor & self, const Tensor & value) const = 0;
  virtual Tensor _th_clone(const Tensor & self) const = 0;
  virtual Tensor _th_view(const Tensor & self, IntArrayRef size) const = 0;
  virtual bool _th_equal(const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor & _th_lt_out(Tensor & result, const Tensor & self, Scalar other) const = 0;
  virtual Tensor _th_lt(const Tensor & self, Scalar other) const = 0;
  virtual Tensor & s__th_lt_out(Tensor & result, const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor & _th_lt_out(Tensor & result, const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor s__th_lt(const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor _th_lt(const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor & _th_gt_out(Tensor & result, const Tensor & self, Scalar other) const = 0;
  virtual Tensor _th_gt(const Tensor & self, Scalar other) const = 0;
  virtual Tensor & s__th_gt_out(Tensor & result, const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor & _th_gt_out(Tensor & result, const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor s__th_gt(const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor _th_gt(const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor & _th_le_out(Tensor & result, const Tensor & self, Scalar other) const = 0;
  virtual Tensor _th_le(const Tensor & self, Scalar other) const = 0;
  virtual Tensor & s__th_le_out(Tensor & result, const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor & _th_le_out(Tensor & result, const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor s__th_le(const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor _th_le(const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor & _th_ge_out(Tensor & result, const Tensor & self, Scalar other) const = 0;
  virtual Tensor _th_ge(const Tensor & self, Scalar other) const = 0;
  virtual Tensor & s__th_ge_out(Tensor & result, const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor & _th_ge_out(Tensor & result, const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor s__th_ge(const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor _th_ge(const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor & _th_eq_out(Tensor & result, const Tensor & self, Scalar other) const = 0;
  virtual Tensor _th_eq(const Tensor & self, Scalar other) const = 0;
  virtual Tensor & s__th_eq_out(Tensor & result, const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor & _th_eq_out(Tensor & result, const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor s__th_eq(const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor _th_eq(const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor & _th_ne_out(Tensor & result, const Tensor & self, Scalar other) const = 0;
  virtual Tensor _th_ne(const Tensor & self, Scalar other) const = 0;
  virtual Tensor & s__th_ne_out(Tensor & result, const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor & _th_ne_out(Tensor & result, const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor s__th_ne(const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor _th_ne(const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor & s__th_min_out(Tensor & result, const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor & _th_min_out(Tensor & result, const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor s__th_min(const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor _th_min(const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor _th_min(const Tensor & self) const = 0;
  virtual std::tuple<Tensor &,Tensor &> _th_min_out(Tensor & min, Tensor & min_indices, const Tensor & self, int64_t dim, bool keepdim) const = 0;
  virtual std::tuple<Tensor,Tensor> _th_min(const Tensor & self, int64_t dim, bool keepdim) const = 0;
  virtual Tensor & s__th_max_out(Tensor & result, const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor & _th_max_out(Tensor & result, const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor s__th_max(const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor _th_max(const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor _th_max(const Tensor & self) const = 0;
  virtual std::tuple<Tensor &,Tensor &> _th_max_out(Tensor & max, Tensor & max_indices, const Tensor & self, int64_t dim, bool keepdim) const = 0;
  virtual std::tuple<Tensor,Tensor> _th_max(const Tensor & self, int64_t dim, bool keepdim) const = 0;
  virtual Tensor & _th_neg_out(Tensor & result, const Tensor & self) const = 0;
  virtual Tensor _th_neg(const Tensor & self) const = 0;
  virtual Tensor & _th_zero_(Tensor & self) const = 0;
  virtual Tensor & _th_remainder_out(Tensor & result, const Tensor & self, Scalar other) const = 0;
  virtual Tensor _th_remainder(const Tensor & self, Scalar other) const = 0;
  virtual Tensor & s__th_remainder_out(Tensor & result, const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor & _th_remainder_out(Tensor & result, const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor s__th_remainder(const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor _th_remainder(const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor & _th_remainder_(Tensor & self, Scalar other) const = 0;
  virtual Tensor & s__th_remainder_(Tensor & self, const Tensor & other) const = 0;
  virtual Tensor & _th_remainder_(Tensor & self, const Tensor & other) const = 0;
  virtual Tensor & s__th_addmm_out(Tensor & result, const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const = 0;
  virtual Tensor & _th_addmm_out(Tensor & result, const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const = 0;
  virtual Tensor s__th_addmm(const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const = 0;
  virtual Tensor _th_addmm(const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const = 0;
  virtual std::tuple<Tensor &,Tensor &> _thnn_max_pool2d_with_indices_forward_out(Tensor & output, Tensor & indices, const Tensor & self, IntArrayRef kernel_size, IntArrayRef stride, IntArrayRef padding, IntArrayRef dilation, bool ceil_mode) const = 0;
  virtual std::tuple<Tensor,Tensor> _thnn_max_pool2d_with_indices_forward(const Tensor & self, IntArrayRef kernel_size, IntArrayRef stride, IntArrayRef padding, IntArrayRef dilation, bool ceil_mode) const = 0;
  virtual std::tuple<Tensor &,Tensor &,Tensor &> _thnn_conv2d_forward_out(Tensor & output, Tensor & finput, Tensor & fgrad_input, const Tensor & self, const Tensor & weight, IntArrayRef kernel_size, const Tensor & bias, IntArrayRef stride, IntArrayRef padding) const = 0;
  virtual std::tuple<Tensor,Tensor,Tensor> _thnn_conv2d_forward(const Tensor & self, const Tensor & weight, IntArrayRef kernel_size, const Tensor & bias, IntArrayRef stride, IntArrayRef padding) const = 0;
  virtual Tensor & all_out(Tensor & out, const Tensor & self, int64_t dim, bool keepdim) const = 0;
  virtual Tensor batch_norm(const Tensor & input, const Tensor & weight, const Tensor & bias, const Tensor & running_mean, const Tensor & running_var, bool training, double momentum, double eps, bool cudnn_enabled) const = 0;
  virtual std::tuple<Tensor,Tensor,Tensor,int64_t> _batch_norm_impl_index(const Tensor & input, const Tensor & weight, const Tensor & bias, const Tensor & running_mean, const Tensor & running_var, bool training, double momentum, double eps, bool cudnn_enabled) const = 0;
  virtual Tensor _convolution(const Tensor & input, const Tensor & weight, const Tensor & bias, IntArrayRef stride, IntArrayRef padding, IntArrayRef dilation, bool transposed, IntArrayRef output_padding, int64_t groups, bool benchmark, bool deterministic, bool cudnn_enabled) const = 0;
  virtual Tensor _convolution_nogroup(const Tensor & input, const Tensor & weight, const Tensor & bias, IntArrayRef stride, IntArrayRef padding, IntArrayRef dilation, bool transposed, IntArrayRef output_padding) const = 0;
  virtual Tensor & s_copy_(Tensor & self, const Tensor & src, bool non_blocking) const = 0;
  virtual void _copy_same_type_(Tensor & self, const Tensor & src) const = 0;
  virtual Tensor empty(IntArrayRef size, const TensorOptions & options) const = 0;
  virtual Tensor empty_like(const Tensor & self) const = 0;
  virtual Tensor empty_like(const Tensor & self, const TensorOptions & options) const = 0;
  virtual Tensor empty_strided(IntArrayRef size, IntArrayRef stride, const TensorOptions & options) const = 0;
  virtual Tensor full(IntArrayRef size, Scalar fill_value, const TensorOptions & options) const = 0;
  virtual Tensor & log_out(Tensor & out, const Tensor & self) const = 0;
  virtual std::tuple<Tensor &,Tensor &> max_out(Tensor & max, Tensor & max_values, const Tensor & self, int64_t dim, bool keepdim) const = 0;
  virtual std::tuple<Tensor &,Tensor &> min_out(Tensor & min, Tensor & min_indices, const Tensor & self, int64_t dim, bool keepdim) const = 0;
  virtual std::tuple<Tensor,Tensor,Tensor> native_batch_norm(const Tensor & input, const Tensor & weight, const Tensor & bias, const Tensor & running_mean, const Tensor & running_var, bool training, double momentum, double eps) const = 0;
  virtual Tensor ones(IntArrayRef size, const TensorOptions & options) const = 0;
  virtual Tensor scalar_tensor(Scalar s, const TensorOptions & options) const = 0;
  virtual Tensor & sum_out(Tensor & out, const Tensor & self, IntArrayRef dim, bool keepdim, ScalarType dtype) const = 0;
  virtual Tensor & sum_out(Tensor & out, const Tensor & self, IntArrayRef dim, bool keepdim) const = 0;
  virtual Tensor & sum_out(Tensor & out, const Tensor & self, IntArrayRef dim, ScalarType dtype) const = 0;
  virtual Tensor & threshold_(Tensor & self, Scalar threshold, Scalar value) const = 0;
  virtual Tensor zeros(IntArrayRef size, const TensorOptions & options) const = 0;
  virtual Tensor native_clone(const Tensor & self) const = 0;
  virtual Tensor & native_zero_(Tensor & self) const = 0;
  virtual Scalar _local_scalar_dense(const Tensor & self) const = 0;
  virtual Tensor & min_out(Tensor & out, const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor & max_out(Tensor & out, const Tensor & self, const Tensor & other) const = 0;
  virtual Tensor adaptive_avg_pool2d(const Tensor & self, IntArrayRef output_size) const = 0;
  virtual Tensor _adaptive_avg_pool2d(const Tensor & self, IntArrayRef output_size) const = 0;
  virtual std::tuple<Tensor,Tensor> max_pool2d_with_indices(const Tensor & self, IntArrayRef kernel_size, IntArrayRef stride, IntArrayRef padding, IntArrayRef dilation, bool ceil_mode) const = 0;
  virtual Tensor thnn_conv2d(const Tensor & self, const Tensor & weight, IntArrayRef kernel_size, const Tensor & bias, IntArrayRef stride, IntArrayRef padding) const = 0;
  virtual std::tuple<Tensor,Tensor,Tensor> thnn_conv2d_forward(const Tensor & self, const Tensor & weight, IntArrayRef kernel_size, const Tensor & bias, IntArrayRef stride, IntArrayRef padding) const = 0;
};

} // namespace at

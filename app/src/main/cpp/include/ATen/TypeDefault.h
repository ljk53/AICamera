#pragma once

// @generated by aten/src/ATen/gen.py

#include <ATen/TypeExtendedInterface.h>

namespace at {

struct CAFFE2_API TypeDefault : public TypeExtendedInterface {
  explicit TypeDefault(TensorTypeId type_id, bool is_variable, bool is_undefined)
      : TypeExtendedInterface(type_id, is_variable, is_undefined) {}

  // Make sure overload resolution considers the nullary virtual method.
  // (A single argument overload is generated in the list.)
  bool is_cuda() const override {
    return backend() == Backend::CUDA || backend() == Backend::SparseCUDA;
  }
  bool is_hip() const override {
    return backend() == Backend::HIP || backend() == Backend::SparseHIP;
  }
  bool is_sparse() const override {
    return backend() == Backend::SparseCPU || backend() == Backend::SparseCUDA || backend() == Backend::SparseHIP;
  }
  bool is_distributed() const override {
    return false;
  }

  Type & toBackend(Backend b) const override;
  Type & toScalarType(ScalarType s) const override;

  Tensor copy(const Tensor & src, bool non_blocking=false, optional<Device> to_device={}) const override;
  Tensor & copy_(Tensor & self, const Tensor & src, bool non_blocking=false) const override;

  void backward(
      Tensor& self,
      c10::optional<Tensor> gradient,
      bool keep_graph,
      bool create_graph) const override;
  void set_data(Tensor & self, Tensor new_data) const override;

  Tensor tensorFromBlob(void * data, IntArrayRef sizes, const std::function<void(void*)> & deleter=noop_deleter) const override;
  Tensor tensorFromBlob(void * data, IntArrayRef sizes, IntArrayRef strides, const std::function<void(void*)> & deleter=noop_deleter) const override;
  Tensor tensorWithAllocator(IntArrayRef sizes, Allocator* allocator) const override;
  Tensor tensorWithAllocator(IntArrayRef sizes, IntArrayRef strides, Allocator* allocator) const override;

  Storage storageFromBlob(void * data, int64_t size, const std::function<void(void*)> & deleter) const override;
  Storage storageWithAllocator(int64_t size, Allocator* allocator) const override;
  Storage unsafeStorageFromTH(void * th_pointer, bool retain) const override;
  Tensor unsafeTensorFromTH(void * th_pointer, bool retain) const override;

  // example
  // virtual Tensor * add(Tensor & a, Tensor & b) = 0;
  Tensor & _th_set_(Tensor & self, Storage source) const override;
  Tensor & _th_set_(Tensor & self, Storage source, int64_t storage_offset, IntArrayRef size, IntArrayRef stride) const override;
  Tensor & _th_set_(Tensor & self, const Tensor & source) const override;
  Tensor & _th_set_(Tensor & self) const override;
  Tensor & _th_fill_(Tensor & self, Scalar value) const override;
  Tensor & _th_fill_(Tensor & self, const Tensor & value) const override;
  Tensor _th_clone(const Tensor & self) const override;
  Tensor _th_view(const Tensor & self, IntArrayRef size) const override;
  bool _th_equal(const Tensor & self, const Tensor & other) const override;
  Tensor & _th_lt_out(Tensor & result, const Tensor & self, Scalar other) const override;
  Tensor _th_lt(const Tensor & self, Scalar other) const override;
  Tensor & _th_lt_out(Tensor & result, const Tensor & self, const Tensor & other) const override;
  Tensor & s__th_lt_out(Tensor & result, const Tensor & self, const Tensor & other) const override;
  Tensor _th_lt(const Tensor & self, const Tensor & other) const override;
  Tensor s__th_lt(const Tensor & self, const Tensor & other) const override;
  Tensor & _th_gt_out(Tensor & result, const Tensor & self, Scalar other) const override;
  Tensor _th_gt(const Tensor & self, Scalar other) const override;
  Tensor & _th_gt_out(Tensor & result, const Tensor & self, const Tensor & other) const override;
  Tensor & s__th_gt_out(Tensor & result, const Tensor & self, const Tensor & other) const override;
  Tensor _th_gt(const Tensor & self, const Tensor & other) const override;
  Tensor s__th_gt(const Tensor & self, const Tensor & other) const override;
  Tensor & _th_le_out(Tensor & result, const Tensor & self, Scalar other) const override;
  Tensor _th_le(const Tensor & self, Scalar other) const override;
  Tensor & _th_le_out(Tensor & result, const Tensor & self, const Tensor & other) const override;
  Tensor & s__th_le_out(Tensor & result, const Tensor & self, const Tensor & other) const override;
  Tensor _th_le(const Tensor & self, const Tensor & other) const override;
  Tensor s__th_le(const Tensor & self, const Tensor & other) const override;
  Tensor & _th_ge_out(Tensor & result, const Tensor & self, Scalar other) const override;
  Tensor _th_ge(const Tensor & self, Scalar other) const override;
  Tensor & _th_ge_out(Tensor & result, const Tensor & self, const Tensor & other) const override;
  Tensor & s__th_ge_out(Tensor & result, const Tensor & self, const Tensor & other) const override;
  Tensor _th_ge(const Tensor & self, const Tensor & other) const override;
  Tensor s__th_ge(const Tensor & self, const Tensor & other) const override;
  Tensor & _th_eq_out(Tensor & result, const Tensor & self, Scalar other) const override;
  Tensor _th_eq(const Tensor & self, Scalar other) const override;
  Tensor & _th_eq_out(Tensor & result, const Tensor & self, const Tensor & other) const override;
  Tensor & s__th_eq_out(Tensor & result, const Tensor & self, const Tensor & other) const override;
  Tensor _th_eq(const Tensor & self, const Tensor & other) const override;
  Tensor s__th_eq(const Tensor & self, const Tensor & other) const override;
  Tensor & _th_ne_out(Tensor & result, const Tensor & self, Scalar other) const override;
  Tensor _th_ne(const Tensor & self, Scalar other) const override;
  Tensor & _th_ne_out(Tensor & result, const Tensor & self, const Tensor & other) const override;
  Tensor & s__th_ne_out(Tensor & result, const Tensor & self, const Tensor & other) const override;
  Tensor _th_ne(const Tensor & self, const Tensor & other) const override;
  Tensor s__th_ne(const Tensor & self, const Tensor & other) const override;
  Tensor & _th_min_out(Tensor & result, const Tensor & self, const Tensor & other) const override;
  Tensor & s__th_min_out(Tensor & result, const Tensor & self, const Tensor & other) const override;
  Tensor _th_min(const Tensor & self, const Tensor & other) const override;
  Tensor s__th_min(const Tensor & self, const Tensor & other) const override;
  Tensor _th_min(const Tensor & self) const override;
  std::tuple<Tensor &,Tensor &> _th_min_out(Tensor & min, Tensor & min_indices, const Tensor & self, int64_t dim, bool keepdim) const override;
  std::tuple<Tensor,Tensor> _th_min(const Tensor & self, int64_t dim, bool keepdim) const override;
  Tensor & _th_max_out(Tensor & result, const Tensor & self, const Tensor & other) const override;
  Tensor & s__th_max_out(Tensor & result, const Tensor & self, const Tensor & other) const override;
  Tensor _th_max(const Tensor & self, const Tensor & other) const override;
  Tensor s__th_max(const Tensor & self, const Tensor & other) const override;
  Tensor _th_max(const Tensor & self) const override;
  std::tuple<Tensor &,Tensor &> _th_max_out(Tensor & max, Tensor & max_indices, const Tensor & self, int64_t dim, bool keepdim) const override;
  std::tuple<Tensor,Tensor> _th_max(const Tensor & self, int64_t dim, bool keepdim) const override;
  Tensor & _th_neg_out(Tensor & result, const Tensor & self) const override;
  Tensor _th_neg(const Tensor & self) const override;
  Tensor & _th_zero_(Tensor & self) const override;
  Tensor & _th_remainder_out(Tensor & result, const Tensor & self, Scalar other) const override;
  Tensor _th_remainder(const Tensor & self, Scalar other) const override;
  Tensor & _th_remainder_out(Tensor & result, const Tensor & self, const Tensor & other) const override;
  Tensor & s__th_remainder_out(Tensor & result, const Tensor & self, const Tensor & other) const override;
  Tensor _th_remainder(const Tensor & self, const Tensor & other) const override;
  Tensor s__th_remainder(const Tensor & self, const Tensor & other) const override;
  Tensor & _th_remainder_(Tensor & self, Scalar other) const override;
  Tensor & _th_remainder_(Tensor & self, const Tensor & other) const override;
  Tensor & s__th_remainder_(Tensor & self, const Tensor & other) const override;
  Tensor & _th_addmm_out(Tensor & result, const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const override;
  Tensor & s__th_addmm_out(Tensor & result, const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const override;
  Tensor _th_addmm(const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const override;
  Tensor s__th_addmm(const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const override;
  std::tuple<Tensor &,Tensor &> _thnn_max_pool2d_with_indices_forward_out(Tensor & output, Tensor & indices, const Tensor & self, IntArrayRef kernel_size, IntArrayRef stride, IntArrayRef padding, IntArrayRef dilation, bool ceil_mode) const override;
  std::tuple<Tensor,Tensor> _thnn_max_pool2d_with_indices_forward(const Tensor & self, IntArrayRef kernel_size, IntArrayRef stride, IntArrayRef padding, IntArrayRef dilation, bool ceil_mode) const override;
  std::tuple<Tensor &,Tensor &,Tensor &> _thnn_conv2d_forward_out(Tensor & output, Tensor & finput, Tensor & fgrad_input, const Tensor & self, const Tensor & weight, IntArrayRef kernel_size, const Tensor & bias, IntArrayRef stride, IntArrayRef padding) const override;
  std::tuple<Tensor,Tensor,Tensor> _thnn_conv2d_forward(const Tensor & self, const Tensor & weight, IntArrayRef kernel_size, const Tensor & bias, IntArrayRef stride, IntArrayRef padding) const override;
  Tensor add(const Tensor & self, const Tensor & other, Scalar alpha) const override;
  Tensor & add_(Tensor & self, const Tensor & other, Scalar alpha) const override;
  Tensor add(const Tensor & self, Scalar other, Scalar alpha) const override;
  Tensor & add_(Tensor & self, Scalar other, Scalar alpha) const override;
  Tensor all(const Tensor & self, int64_t dim, bool keepdim) const override;
  Tensor & all_out(Tensor & out, const Tensor & self, int64_t dim, bool keepdim) const override;
  Tensor as_strided(const Tensor & self, IntArrayRef size, IntArrayRef stride, c10::optional<int64_t> storage_offset) const override;
  Tensor & as_strided_(Tensor & self, IntArrayRef size, IntArrayRef stride, c10::optional<int64_t> storage_offset) const override;
  Tensor batch_norm(const Tensor & input, const Tensor & weight, const Tensor & bias, const Tensor & running_mean, const Tensor & running_var, bool training, double momentum, double eps, bool cudnn_enabled) const override;
  std::tuple<Tensor,Tensor,Tensor,int64_t> _batch_norm_impl_index(const Tensor & input, const Tensor & weight, const Tensor & bias, const Tensor & running_mean, const Tensor & running_var, bool training, double momentum, double eps, bool cudnn_enabled) const override;
  Tensor contiguous(const Tensor & self) const override;
  Tensor _convolution(const Tensor & input, const Tensor & weight, const Tensor & bias, IntArrayRef stride, IntArrayRef padding, IntArrayRef dilation, bool transposed, IntArrayRef output_padding, int64_t groups, bool benchmark, bool deterministic, bool cudnn_enabled) const override;
  Tensor _convolution_nogroup(const Tensor & input, const Tensor & weight, const Tensor & bias, IntArrayRef stride, IntArrayRef padding, IntArrayRef dilation, bool transposed, IntArrayRef output_padding) const override;
  Tensor & s_copy_(Tensor & self, const Tensor & src, bool non_blocking) const override;
  void _copy_same_type_(Tensor & self, const Tensor & src) const override;
  Tensor div(const Tensor & self, const Tensor & other) const override;
  Tensor & div_(Tensor & self, const Tensor & other) const override;
  Tensor div(const Tensor & self, Scalar other) const override;
  Tensor & div_(Tensor & self, Scalar other) const override;
  Tensor empty(IntArrayRef size, const TensorOptions & options) const override;
  Tensor & resize_(Tensor & self, IntArrayRef size) const override;
  Tensor empty_like(const Tensor & self) const override;
  Tensor empty_like(const Tensor & self, const TensorOptions & options) const override;
  Tensor empty_strided(IntArrayRef size, IntArrayRef stride, const TensorOptions & options) const override;
  Tensor expand(const Tensor & self, IntArrayRef size, bool implicit) const override;
  Tensor & fill_(Tensor & self, Scalar value) const override;
  Tensor & fill_(Tensor & self, const Tensor & value) const override;
  Tensor full(IntArrayRef size, Scalar fill_value, const TensorOptions & options) const override;
  bool is_nonzero(const Tensor & self) const override;
  Tensor & log_(Tensor & self) const override;
  Tensor & log_out(Tensor & out, const Tensor & self) const override;
  std::tuple<Tensor,Tensor> max(const Tensor & self, int64_t dim, bool keepdim) const override;
  std::tuple<Tensor &,Tensor &> max_out(Tensor & max, Tensor & max_values, const Tensor & self, int64_t dim, bool keepdim) const override;
  Tensor mean(const Tensor & self, ScalarType dtype) const override;
  Tensor mean(const Tensor & self) const override;
  Tensor mean(const Tensor & self, IntArrayRef dim, bool keepdim, ScalarType dtype) const override;
  Tensor mean(const Tensor & self, IntArrayRef dim, bool keepdim) const override;
  Tensor mean(const Tensor & self, IntArrayRef dim, ScalarType dtype) const override;
  std::tuple<Tensor,Tensor> min(const Tensor & self, int64_t dim, bool keepdim) const override;
  std::tuple<Tensor &,Tensor &> min_out(Tensor & min, Tensor & min_indices, const Tensor & self, int64_t dim, bool keepdim) const override;
  Tensor mul(const Tensor & self, const Tensor & other) const override;
  Tensor & mul_(Tensor & self, const Tensor & other) const override;
  Tensor mul(const Tensor & self, Scalar other) const override;
  Tensor & mul_(Tensor & self, Scalar other) const override;
  Tensor narrow(const Tensor & self, int64_t dim, int64_t start, int64_t length) const override;
  std::tuple<Tensor,Tensor,Tensor> native_batch_norm(const Tensor & input, const Tensor & weight, const Tensor & bias, const Tensor & running_mean, const Tensor & running_var, bool training, double momentum, double eps) const override;
  Tensor ones(IntArrayRef size, const TensorOptions & options) const override;
  Tensor permute(const Tensor & self, IntArrayRef dims) const override;
  Tensor scalar_tensor(Scalar s, const TensorOptions & options) const override;
  Tensor select(const Tensor & self, int64_t dim, int64_t index) const override;
  int64_t size(const Tensor & self, int64_t dim) const override;
  Tensor slice(const Tensor & self, int64_t dim, int64_t start, int64_t end, int64_t step) const override;
  Tensor squeeze(const Tensor & self) const override;
  Tensor squeeze(const Tensor & self, int64_t dim) const override;
  Tensor & squeeze_(Tensor & self) const override;
  Tensor & squeeze_(Tensor & self, int64_t dim) const override;
  int64_t stride(const Tensor & self, int64_t dim) const override;
  Tensor sum(const Tensor & self, ScalarType dtype) const override;
  Tensor sum(const Tensor & self) const override;
  Tensor sum(const Tensor & self, IntArrayRef dim, bool keepdim, ScalarType dtype) const override;
  Tensor sum(const Tensor & self, IntArrayRef dim, bool keepdim) const override;
  Tensor sum(const Tensor & self, IntArrayRef dim, ScalarType dtype) const override;
  Tensor & sum_out(Tensor & out, const Tensor & self, IntArrayRef dim, bool keepdim, ScalarType dtype) const override;
  Tensor & sum_out(Tensor & out, const Tensor & self, IntArrayRef dim, bool keepdim) const override;
  Tensor & sum_out(Tensor & out, const Tensor & self, IntArrayRef dim, ScalarType dtype) const override;
  Tensor t(const Tensor & self) const override;
  Tensor & threshold_(Tensor & self, Scalar threshold, Scalar value) const override;
  Tensor transpose(const Tensor & self, int64_t dim0, int64_t dim1) const override;
  Tensor unsqueeze(const Tensor & self, int64_t dim) const override;
  Tensor zeros(IntArrayRef size, const TensorOptions & options) const override;
  Tensor native_clone(const Tensor & self) const override;
  Tensor clone(const Tensor & self) const override;
  Tensor & native_zero_(Tensor & self) const override;
  Tensor & zero_(Tensor & self) const override;
  Tensor sub(const Tensor & self, const Tensor & other, Scalar alpha) const override;
  Tensor & sub_(Tensor & self, const Tensor & other, Scalar alpha) const override;
  Tensor sub(const Tensor & self, Scalar other, Scalar alpha) const override;
  Tensor & sub_(Tensor & self, Scalar other, Scalar alpha) const override;
  Tensor addmm(const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta, Scalar alpha) const override;
  int64_t sparse_dim(const Tensor & self) const override;
  int64_t dense_dim(const Tensor & self) const override;
  Tensor _indices(const Tensor & self) const override;
  Tensor _values(const Tensor & self) const override;
  int64_t numel(const Tensor & self) const override;
  Tensor to(const Tensor & self, const TensorOptions & options, bool non_blocking, bool copy) const override;
  Tensor to(const Tensor & self, Device device, ScalarType dtype, bool non_blocking, bool copy) const override;
  Tensor to(const Tensor & self, ScalarType dtype, bool non_blocking, bool copy) const override;
  Tensor to(const Tensor & self, const Tensor & other, bool non_blocking, bool copy) const override;
  Scalar item(const Tensor & self) const override;
  Scalar _local_scalar_dense(const Tensor & self) const override;
  void* data_ptr(const Tensor & self) const override;
  Tensor & set_(Tensor & self, Storage source) const override;
  Tensor & set_(Tensor & self, Storage source, int64_t storage_offset, IntArrayRef size, IntArrayRef stride) const override;
  Tensor & set_(Tensor & self, const Tensor & source) const override;
  Tensor & set_(Tensor & self) const override;
  Tensor view(const Tensor & self, IntArrayRef size) const override;
  Tensor & remainder_(Tensor & self, Scalar other) const override;
  Tensor & remainder_(Tensor & self, const Tensor & other) const override;
  Tensor ne(const Tensor & self, Scalar other) const override;
  Tensor ne(const Tensor & self, const Tensor & other) const override;
  Tensor eq(const Tensor & self, Scalar other) const override;
  Tensor eq(const Tensor & self, const Tensor & other) const override;
  Tensor ge(const Tensor & self, Scalar other) const override;
  Tensor ge(const Tensor & self, const Tensor & other) const override;
  Tensor le(const Tensor & self, Scalar other) const override;
  Tensor le(const Tensor & self, const Tensor & other) const override;
  Tensor gt(const Tensor & self, Scalar other) const override;
  Tensor gt(const Tensor & self, const Tensor & other) const override;
  Tensor lt(const Tensor & self, Scalar other) const override;
  Tensor lt(const Tensor & self, const Tensor & other) const override;
  Tensor neg(const Tensor & self) const override;
  Tensor remainder(const Tensor & self, Scalar other) const override;
  Tensor remainder(const Tensor & self, const Tensor & other) const override;
  Tensor & min_out(Tensor & out, const Tensor & self, const Tensor & other) const override;
  Tensor min(const Tensor & self, const Tensor & other) const override;
  Tensor min(const Tensor & self) const override;
  Tensor & max_out(Tensor & out, const Tensor & self, const Tensor & other) const override;
  Tensor max(const Tensor & self, const Tensor & other) const override;
  Tensor max(const Tensor & self) const override;
  Tensor all(const Tensor & self) const override;
  bool equal(const Tensor & self, const Tensor & other) const override;
  Tensor adaptive_avg_pool2d(const Tensor & self, IntArrayRef output_size) const override;
  Tensor _adaptive_avg_pool2d(const Tensor & self, IntArrayRef output_size) const override;
  std::tuple<Tensor,Tensor> max_pool2d_with_indices(const Tensor & self, IntArrayRef kernel_size, IntArrayRef stride, IntArrayRef padding, IntArrayRef dilation, bool ceil_mode) const override;
  Tensor thnn_conv2d(const Tensor & self, const Tensor & weight, IntArrayRef kernel_size, const Tensor & bias, IntArrayRef stride, IntArrayRef padding) const override;
  std::tuple<Tensor,Tensor,Tensor> thnn_conv2d_forward(const Tensor & self, const Tensor & weight, IntArrayRef kernel_size, const Tensor & bias, IntArrayRef stride, IntArrayRef padding) const override;
};

} // namespace at

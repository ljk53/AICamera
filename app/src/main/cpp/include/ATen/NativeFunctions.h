#pragma once

// @generated by aten/src/ATen/gen.py

#include <ATen/Context.h>
#include <c10/core/ScalarType.h>
#include <ATen/core/TensorMethods.h>
#include <c10/core/TensorOptions.h>

#include <array>
#include <functional>
#include <string>
#include <tuple>
#include <vector>

namespace c10 {
class Scalar;
}
namespace at {
struct Generator;
class Tensor;
struct Type;
} // namespace at

namespace at {
namespace native {

inline Tensor from_blob(
    void* data,
    IntArrayRef sizes,
    const std::function<void(void*)>& deleter,
    const TensorOptions& options = {}) {
  return at::getType(options).tensorFromBlob(data, sizes, deleter);
}

inline Tensor from_blob(
    void* data,
    IntArrayRef sizes,
    IntArrayRef strides,
    const std::function<void(void*)>& deleter,
    const TensorOptions& options = {}) {
  return at::getType(options).tensorFromBlob(data, sizes, strides, deleter);
}

// These functions are defined in native/TensorFactories.cpp.
#define TENSOR(T, S, _1)                                                      \
  CAFFE2_API Tensor tensor(ArrayRef<T> values, const TensorOptions& options); \
  inline Tensor tensor(                                                       \
      std::initializer_list<T> values, const TensorOptions& options) {        \
    return native::tensor(ArrayRef<T>(values), options);                      \
  }                                                                           \
  inline Tensor tensor(T value, const TensorOptions& options) {               \
    return native::tensor(ArrayRef<T>(value), options);                       \
  }                                                                           \
  inline Tensor tensor(ArrayRef<T> values) {                                  \
    return native::tensor(std::move(values), at::dtype(k##S));                \
  }                                                                           \
  inline Tensor tensor(std::initializer_list<T> values) {                     \
    return native::tensor(ArrayRef<T>(values));                               \
  }                                                                           \
  inline Tensor tensor(T value) {                                             \
    return native::tensor(ArrayRef<T>(value));                                \
  }
AT_FORALL_SCALAR_TYPES_EXCEPT_HALF(TENSOR)
#undef TENSOR

CAFFE2_API Tensor add(const Tensor & self, const Tensor & other, Scalar alpha=1);
CAFFE2_API Tensor & add_(Tensor & self, const Tensor & other, Scalar alpha=1);
CAFFE2_API Tensor add(const Tensor & self, Scalar other, Scalar alpha=1);
CAFFE2_API Tensor & add_(Tensor & self, Scalar other, Scalar alpha=1);
CAFFE2_API Tensor all(const Tensor & self, int64_t dim, bool keepdim=false);
CAFFE2_API Tensor & all_out(Tensor & out, const Tensor & self, int64_t dim, bool keepdim=false);
CAFFE2_API Tensor as_strided(const Tensor & self, IntArrayRef size, IntArrayRef stride, c10::optional<int64_t> storage_offset=c10::nullopt);
CAFFE2_API Tensor & as_strided_(Tensor & self, IntArrayRef size, IntArrayRef stride, c10::optional<int64_t> storage_offset=c10::nullopt);
CAFFE2_API Tensor batch_norm(const Tensor & input, const Tensor & weight, const Tensor & bias, const Tensor & running_mean, const Tensor & running_var, bool training, double momentum, double eps, bool cudnn_enabled);
CAFFE2_API std::tuple<Tensor,Tensor,Tensor,int64_t> _batch_norm_impl_index(const Tensor & input, const Tensor & weight, const Tensor & bias, const Tensor & running_mean, const Tensor & running_var, bool training, double momentum, double eps, bool cudnn_enabled);
CAFFE2_API Tensor contiguous(const Tensor & self);
CAFFE2_API Tensor _convolution(const Tensor & input, const Tensor & weight, const Tensor & bias, IntArrayRef stride, IntArrayRef padding, IntArrayRef dilation, bool transposed, IntArrayRef output_padding, int64_t groups, bool benchmark, bool deterministic, bool cudnn_enabled);
CAFFE2_API Tensor _convolution_nogroup(const Tensor & input, const Tensor & weight, const Tensor & bias, IntArrayRef stride, IntArrayRef padding, IntArrayRef dilation, bool transposed, IntArrayRef output_padding);
CAFFE2_API Tensor & _s_copy__cpu(Tensor & self, const Tensor & src, bool non_blocking=false);
CAFFE2_API Tensor & _s_copy__cuda(Tensor & self, const Tensor & src, bool non_blocking=false);
CAFFE2_API void _copy_same_type__cpu(Tensor & self, const Tensor & src);
CAFFE2_API Tensor div(const Tensor & self, const Tensor & other);
CAFFE2_API Tensor & div_(Tensor & self, const Tensor & other);
CAFFE2_API Tensor div(const Tensor & self, Scalar other);
CAFFE2_API Tensor & div_(Tensor & self, Scalar other);
CAFFE2_API Tensor empty_cpu(IntArrayRef size, const TensorOptions & options={});
CAFFE2_API Tensor empty_cuda(IntArrayRef size, const TensorOptions & options={});
CAFFE2_API Tensor empty_sparse(IntArrayRef size, const TensorOptions & options={});
CAFFE2_API Tensor & resize_cpu_(Tensor & self, IntArrayRef size);
CAFFE2_API Tensor & resize_cuda_(Tensor & self, IntArrayRef size);
CAFFE2_API Tensor empty_like(const Tensor & self);
CAFFE2_API Tensor empty_like(const Tensor & self, const TensorOptions & options);
CAFFE2_API Tensor empty_strided_cpu(IntArrayRef size, IntArrayRef stride, const TensorOptions & options={});
CAFFE2_API Tensor empty_strided_cuda(IntArrayRef size, IntArrayRef stride, const TensorOptions & options={});
CAFFE2_API Tensor expand(const Tensor & self, IntArrayRef size, bool implicit=false);
CAFFE2_API Tensor & fill_(Tensor & self, Scalar value);
CAFFE2_API Tensor & fill_(Tensor & self, const Tensor & value);
CAFFE2_API Tensor full(IntArrayRef size, Scalar fill_value, const TensorOptions & options={});
CAFFE2_API bool is_nonzero(const Tensor & self);
CAFFE2_API Tensor & _log__cpu(Tensor & self);
CAFFE2_API Tensor & _log__cuda(Tensor & self);
CAFFE2_API Tensor & _log_out_cpu(Tensor & out, const Tensor & self);
CAFFE2_API Tensor & _log_out_cuda(Tensor & out, const Tensor & self);
CAFFE2_API std::tuple<Tensor,Tensor> max(const Tensor & self, int64_t dim, bool keepdim=false);
CAFFE2_API std::tuple<Tensor &,Tensor &> max_out(Tensor & max, Tensor & max_values, const Tensor & self, int64_t dim, bool keepdim=false);
CAFFE2_API Tensor mean(const Tensor & self, ScalarType dtype);
CAFFE2_API Tensor mean(const Tensor & self);
CAFFE2_API Tensor mean(const Tensor & self, IntArrayRef dim, bool keepdim, ScalarType dtype);
CAFFE2_API Tensor mean(const Tensor & self, IntArrayRef dim, bool keepdim=false);
CAFFE2_API Tensor mean(const Tensor & self, IntArrayRef dim, ScalarType dtype);
CAFFE2_API std::tuple<Tensor,Tensor> min(const Tensor & self, int64_t dim, bool keepdim=false);
CAFFE2_API std::tuple<Tensor &,Tensor &> min_out(Tensor & min, Tensor & min_indices, const Tensor & self, int64_t dim, bool keepdim=false);
CAFFE2_API Tensor mul(const Tensor & self, const Tensor & other);
CAFFE2_API Tensor & mul_(Tensor & self, const Tensor & other);
CAFFE2_API Tensor mul(const Tensor & self, Scalar other);
CAFFE2_API Tensor & mul_(Tensor & self, Scalar other);
CAFFE2_API Tensor narrow(const Tensor & self, int64_t dim, int64_t start, int64_t length);
CAFFE2_API std::tuple<Tensor,Tensor,Tensor> batch_norm_cpu(const Tensor & input, const Tensor & weight, const Tensor & bias, const Tensor & running_mean, const Tensor & running_var, bool training, double momentum, double eps);
CAFFE2_API std::tuple<Tensor,Tensor,Tensor> batch_norm_cuda(const Tensor & input, const Tensor & weight, const Tensor & bias, const Tensor & running_mean, const Tensor & running_var, bool training, double momentum, double eps);
CAFFE2_API Tensor ones(IntArrayRef size, const TensorOptions & options={});
CAFFE2_API Tensor permute(const Tensor & self, IntArrayRef dims);
CAFFE2_API Tensor scalar_tensor(Scalar s, const TensorOptions & options={});
CAFFE2_API Tensor select(const Tensor & self, int64_t dim, int64_t index);
CAFFE2_API int64_t size(const Tensor & self, int64_t dim);
CAFFE2_API Tensor slice(const Tensor & self, int64_t dim=0, int64_t start=0, int64_t end=9223372036854775807, int64_t step=1);
CAFFE2_API Tensor squeeze(const Tensor & self);
CAFFE2_API Tensor squeeze(const Tensor & self, int64_t dim);
CAFFE2_API Tensor & squeeze_(Tensor & self);
CAFFE2_API Tensor & squeeze_(Tensor & self, int64_t dim);
CAFFE2_API int64_t stride(const Tensor & self, int64_t dim);
CAFFE2_API Tensor sum(const Tensor & self, ScalarType dtype);
CAFFE2_API Tensor sum(const Tensor & self);
CAFFE2_API Tensor sum(const Tensor & self, IntArrayRef dim, bool keepdim, ScalarType dtype);
CAFFE2_API Tensor sum(const Tensor & self, IntArrayRef dim, bool keepdim=false);
CAFFE2_API Tensor sum(const Tensor & self, IntArrayRef dim, ScalarType dtype);
CAFFE2_API Tensor & sum_out(Tensor & out, const Tensor & self, IntArrayRef dim, bool keepdim, ScalarType dtype);
CAFFE2_API Tensor & sum_out(Tensor & out, const Tensor & self, IntArrayRef dim, bool keepdim=false);
CAFFE2_API Tensor & sum_out(Tensor & out, const Tensor & self, IntArrayRef dim, ScalarType dtype);
CAFFE2_API Tensor t(const Tensor & self);
CAFFE2_API Tensor & threshold_(Tensor & self, Scalar threshold, Scalar value);
CAFFE2_API Tensor transpose(const Tensor & self, int64_t dim0, int64_t dim1);
CAFFE2_API Tensor unsqueeze(const Tensor & self, int64_t dim);
CAFFE2_API Tensor zeros(IntArrayRef size, const TensorOptions & options={});
CAFFE2_API Tensor clone_sparse(const Tensor & self);
CAFFE2_API Tensor clone(const Tensor & self);
CAFFE2_API Tensor & zero_sparse_(Tensor & self);
CAFFE2_API Tensor & zero_(Tensor & self);
CAFFE2_API Tensor sub(const Tensor & self, const Tensor & other, Scalar alpha=1);
CAFFE2_API Tensor & sub_(Tensor & self, const Tensor & other, Scalar alpha=1);
CAFFE2_API Tensor sub(const Tensor & self, Scalar other, Scalar alpha=1);
CAFFE2_API Tensor & sub_(Tensor & self, Scalar other, Scalar alpha=1);
CAFFE2_API Tensor addmm(const Tensor & self, const Tensor & mat1, const Tensor & mat2, Scalar beta=1, Scalar alpha=1);
CAFFE2_API int64_t sparse_dim_sparse(const Tensor & self);
CAFFE2_API int64_t dense_dim_sparse(const Tensor & self);
CAFFE2_API Tensor _indices_sparse(const Tensor & self);
CAFFE2_API Tensor _values_sparse(const Tensor & self);
CAFFE2_API int64_t numel(const Tensor & self);
CAFFE2_API Tensor to(const Tensor & self, const TensorOptions & options, bool non_blocking=false, bool copy=false);
CAFFE2_API Tensor to(const Tensor & self, Device device, ScalarType dtype, bool non_blocking=false, bool copy=false);
CAFFE2_API Tensor to(const Tensor & self, ScalarType dtype, bool non_blocking=false, bool copy=false);
CAFFE2_API Tensor to(const Tensor & self, const Tensor & other, bool non_blocking=false, bool copy=false);
CAFFE2_API Scalar item(const Tensor & self);
CAFFE2_API Scalar _local_scalar_dense_cpu(const Tensor & self);
CAFFE2_API Scalar _local_scalar_dense_cuda(const Tensor & self);
CAFFE2_API void* data_ptr(const Tensor & self);
CAFFE2_API Tensor & set_(Tensor & self, Storage source);
CAFFE2_API Tensor & set_(Tensor & self, Storage source, int64_t storage_offset, IntArrayRef size, IntArrayRef stride={});
CAFFE2_API Tensor & set_(Tensor & self, const Tensor & source);
CAFFE2_API Tensor & set_(Tensor & self);
CAFFE2_API Tensor view(const Tensor & self, IntArrayRef size);
CAFFE2_API Tensor & remainder_(Tensor & self, Scalar other);
CAFFE2_API Tensor & remainder_(Tensor & self, const Tensor & other);
CAFFE2_API Tensor ne(const Tensor & self, Scalar other);
CAFFE2_API Tensor ne(const Tensor & self, const Tensor & other);
CAFFE2_API Tensor eq(const Tensor & self, Scalar other);
CAFFE2_API Tensor eq(const Tensor & self, const Tensor & other);
CAFFE2_API Tensor ge(const Tensor & self, Scalar other);
CAFFE2_API Tensor ge(const Tensor & self, const Tensor & other);
CAFFE2_API Tensor le(const Tensor & self, Scalar other);
CAFFE2_API Tensor le(const Tensor & self, const Tensor & other);
CAFFE2_API Tensor gt(const Tensor & self, Scalar other);
CAFFE2_API Tensor gt(const Tensor & self, const Tensor & other);
CAFFE2_API Tensor lt(const Tensor & self, Scalar other);
CAFFE2_API Tensor lt(const Tensor & self, const Tensor & other);
CAFFE2_API Tensor neg(const Tensor & self);
CAFFE2_API Tensor remainder(const Tensor & self, Scalar other);
CAFFE2_API Tensor remainder(const Tensor & self, const Tensor & other);
CAFFE2_API Tensor & min_out(Tensor & out, const Tensor & self, const Tensor & other);
CAFFE2_API Tensor min(const Tensor & self, const Tensor & other);
CAFFE2_API Tensor min(const Tensor & self);
CAFFE2_API Tensor & max_out(Tensor & out, const Tensor & self, const Tensor & other);
CAFFE2_API Tensor max(const Tensor & self, const Tensor & other);
CAFFE2_API Tensor max(const Tensor & self);
CAFFE2_API Tensor all(const Tensor & self);
CAFFE2_API bool equal(const Tensor & self, const Tensor & other);
CAFFE2_API Tensor adaptive_avg_pool2d(const Tensor & self, IntArrayRef output_size);
CAFFE2_API Tensor adaptive_avg_pool2d_cpu(const Tensor & self, IntArrayRef output_size);
CAFFE2_API Tensor adaptive_avg_pool2d_cuda(const Tensor & self, IntArrayRef output_size);
CAFFE2_API std::tuple<Tensor,Tensor> max_pool2d_with_indices(const Tensor & self, IntArrayRef kernel_size, IntArrayRef stride={}, IntArrayRef padding=0, IntArrayRef dilation=1, bool ceil_mode=false);
CAFFE2_API Tensor thnn_conv2d(const Tensor & self, const Tensor & weight, IntArrayRef kernel_size, const Tensor & bias={}, IntArrayRef stride=1, IntArrayRef padding=0);
CAFFE2_API std::tuple<Tensor,Tensor,Tensor> thnn_conv2d_forward(const Tensor & self, const Tensor & weight, IntArrayRef kernel_size, const Tensor & bias, IntArrayRef stride, IntArrayRef padding);

} // namespace native
} // namespace at
